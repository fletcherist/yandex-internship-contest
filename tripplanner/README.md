# Сортировщик карточек путешественника

Начнём решение задания с анализа приведённого в качестве примера описания.
<img src='https://pp.userapi.com/c638824/v638824043/2bd99/kk_aZG_oDF8.jpg' width=700/>

Можно заметить, что наша задача заключается в дописывании ключевых слов **take**, **from**, **to**, и определенного артикля **the** там, где это необходимо.

> P.S. Это прекрасно, что путешественник владеет английским языком, ведь иначе пришлось бы реализовывать функциональность склонений и падежей.

### От слов к делу
Представим полученные нами данные в виде графа, чтобы можно было легче найти закономерность.

<img src='https://pp.userapi.com/c638824/v638824043/2be57/h7qGu7HF_tA.jpg' width=700/>

Из иллюстрации, приведенной выше, становаится ясно, что первая карточка — та, у которой **пункт отправления не соответсвует пункту назначения** ни одной из карточек.

То же самое (только перевёрнутое) можно сказать и о последней карточке путешествия — её **точка назначения не соответствует точке отправления** ни одной из карточек.

Решаем задачу на двух хеш-таблицах. В первую мы помещаем карточки такие, что **ключ** `===` **месту отправления (startingPoint)**. Во вторую — такие, что **ключ** `===` **месту назначения (destinationPoint)**

**O(n)**
```javascript
const tables = {
  startingPoint: {},
  destinationPoint: {}
}

for (const card of this.cards) {
  tables.startingPoint[card.startingPoint] = card
  tables.destinationPoint[card.destinationPoint] = card
}
```

Проходимся по ключам первой таблицы и ищём во второй, как я уже говорил, такую карточку, что её **пункта отправления** нет в хеш-таблице пунктов назначения.

**O(n)**
```javascript
for (const key in tables.startingPoint) {
  if (!tables.destinationPoint.hasOwnProperty(key)) {
    this.sortedCards.push(tables.startingPoint[key])
    break
  }
}
```

Дальше задача сводится к поиску таких двух карточек, что **(место отправления одной)** `===` **(месту прибытия другой)** — другими словами, собираем из нашего массива граф.

**O(n)**
```javascript
for (let i = 0; i < this.cards.length; i++) {
  const currentCard = this.sortedCards[i]
  const nextCard = tables.startingPoint[currentCard.destinationPoint]
  this.sortedCards.push(nextCard)
}
```

Таким образом, мы получили сортировку карточек с алгоритмической сложностью **O(n)**
